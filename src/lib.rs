/*
 * Copyright 2024 Oxide Computer Company
 */

use std::time::{SystemTime, UNIX_EPOCH};

const MAGIC_PREFIX_DEFAULT: [u8; 8] = *b"byo.e.m.";

const MAGIC_SUPER_PREFIX: [u8; 6] = *b"oxauth";
const MAGIC_SUPER_SUFFIX: [u8; 6] = *b"htuaxo";

pub mod agent;
pub mod keydir;
pub mod keyfile;
pub mod signer;
pub mod token;
pub mod unverified;

pub use signer::TokenSigner;
pub use ssh_key::{PrivateKey, PublicKey};
pub use unverified::UnverifiedToken;

use token::TokenIdentity;

fn now_secs() -> u64 {
    SystemTime::now().duration_since(UNIX_EPOCH).unwrap().as_secs()
}

/**
 * Validate the identity name.  The identity name must be safe to use as a file
 * name in the key directory; e.g., it must not be allowed to be empty or to
 * contain path separators like "/".
 */
fn valid_identity(identity: &str) -> bool {
    identity.len() >= 2
        && identity
            .chars()
            .all(|c| c.is_ascii_alphanumeric() || c == '-' || c == '_')
}

#[derive(Debug)]
pub struct VerifiedToken {
    fingerprint: ssh_key::Fingerprint,
    identity: Option<TokenIdentity>,
}

impl VerifiedToken {
    /**
     * The SSH key fingerprint that was used to complete verification.  If the
     * signer provided a key fingerprint, it has been confirmed to match the
     * actual key fingerprint used while verifying the signature.  Uses the
     * format that OpenSSH emits; e.g.,
     * "SHA256:emmapfbH7ufpNaPEJjxwvTW7EupyopNdb9Rio0Yyc7s".
     */
    pub fn fingerprint(&self) -> String {
        self.fingerprint.to_string()
    }

    pub fn identity_filename(&self) -> Option<&str> {
        match &self.identity {
            Some(TokenIdentity::FileName(name)) => Some(name.as_str()),
            _ => None,
        }
    }
}

impl std::fmt::Display for VerifiedToken {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        if let Some(id) = self.identity_filename() {
            write!(f, "[ID:{id}:{}]", self.fingerprint())
        } else {
            write!(f, "[ID:{}]", self.fingerprint())
        }
    }
}

#[cfg(test)]
mod test {
    use crate::*;
    use anyhow::{bail, Result};

    #[allow(unused)]
    struct TestKey {
        id: &'static str,
        pubkey_str: &'static str,
        privkey_str: &'static str,
        pubkey: PublicKey,
        privkey: PrivateKey,
    }

    impl TestKey {
        fn fingerprint(&self) -> String {
            self.pubkey.fingerprint(ssh_key::HashAlg::Sha256).to_string()
        }
    }

    fn load_key(
        (id, privkey_str, pubkey_str): (
            &'static str,
            &'static str,
            &'static str,
        ),
    ) -> Result<TestKey> {
        let privkey = PrivateKey::from_openssh(privkey_str)?;
        let pubkey = privkey.public_key().to_owned();

        let fp = pubkey.fingerprint(ssh_key::HashAlg::Sha256).to_string();
        println!("   [{id}] -> {fp:?}");

        /*
         * Make sure the public key in the test input file is the same as
         * the one generated by looking at the private key:
         */
        let pubkeyf = PublicKey::from_openssh(pubkey_str)?;
        assert_eq!(
            pubkey.fingerprint(ssh_key::HashAlg::Sha256),
            pubkeyf.fingerprint(ssh_key::HashAlg::Sha256),
        );

        Ok(TestKey { id, pubkey_str, privkey_str, pubkey, privkey })
    }

    fn load_keys_ecdsa256() -> Result<Vec<TestKey>> {
        [
            (
                "ecdsa256-test-1",
                include_str!("../testdata/keys/ecdsa256/test-1"),
                include_str!("../testdata/keys/ecdsa256/test-1.pub"),
            ),
            (
                "ecdsa256-test-2",
                include_str!("../testdata/keys/ecdsa256/test-2"),
                include_str!("../testdata/keys/ecdsa256/test-2.pub"),
            ),
        ]
        .into_iter()
        .map(load_key)
        .collect::<Result<Vec<_>>>()
    }

    fn load_keys_ed25519() -> Result<Vec<TestKey>> {
        [
            (
                "ed25519-test-1",
                include_str!("../testdata/keys/ed25519/test-1"),
                include_str!("../testdata/keys/ed25519/test-1.pub"),
            ),
            (
                "ed25519-test-2",
                include_str!("../testdata/keys/ed25519/test-2"),
                include_str!("../testdata/keys/ed25519/test-2.pub"),
            ),
        ]
        .into_iter()
        .map(load_key)
        .collect::<Result<Vec<_>>>()
    }

    #[tokio::test]
    async fn file_signing() -> Result<()> {
        println!();

        let inputs = load_keys_ecdsa256()?
            .into_iter()
            .chain(load_keys_ed25519()?.into_iter())
            .collect::<Vec<_>>();
        for (itk, tk) in inputs.iter().enumerate() {
            let ts = TokenSigner::using_private_key(tk.privkey.clone())?
                .magic_prefix(*b"abcdefgh")
                .identity_filename(tk.id)
                .include_fingerprint(true)
                .build()?;

            let sig =
                ts.sign_for().action("a", "b").action("c", "d").sign().await?;

            let tok = sig.encode();

            println!("   tok[{}] -> {tok}", tk.id);

            let ut = UnverifiedToken::try_from(tok.as_str())?;

            for (ivk, vk) in inputs.iter().enumerate() {
                match ut
                    .verify_for()
                    .magic_prefix(*b"abcdefgh")
                    .action("a", "b")
                    .action("c", "d")
                    .with_key(&vk.pubkey)
                {
                    Ok(vt) => {
                        assert_eq!(ivk, itk);
                        assert_eq!(vt.fingerprint(), tk.fingerprint());
                        println!("verify with {}: {vt}", vk.id);
                    }
                    Err(e) => {
                        assert_ne!(ivk, itk);
                        println!("verify with {}: {e}", vk.id);
                    }
                }
            }
        }

        Ok(())
    }

    #[tokio::test]
    async fn old_sigs() -> Result<()> {
        println!();

        let inputs = load_keys_ecdsa256()?
            .into_iter()
            .chain(load_keys_ed25519()?.into_iter())
            .collect::<Vec<_>>();

        let sigs = include_str!("../testdata/sigs.txt")
            .lines()
            .map(|l| l.split_once('\t').unwrap())
            .collect::<Vec<_>>();

        for (id, token) in sigs {
            let ut = UnverifiedToken::try_from(token)?;

            assert_eq!(id, ut.untrusted_identity_filename().unwrap());

            let key = inputs.iter().find(|tk| tk.id == id).unwrap();

            match ut
                .verify_for()
                .magic_prefix(*b"abcdefgh")
                .action("a", "b")
                .action("c", "d")
                .with_key(&key.pubkey)
            {
                Ok(vt) => {
                    bail!("token is old, should fail: {token:?}, got {vt}")
                }
                Err(e) => {
                    println!("failed, as expected: {e}");
                    let es = e.to_string();

                    assert!(
                        es.contains("delta of")
                            && es.contains("seconds is too great")
                    );
                }
            }

            let vt = ut
                .verify_for()
                .magic_prefix(*b"abcdefgh")
                .action("a", "b")
                .action("c", "d")
                /*
                 * Temporarily accept tokens up to ten years old:
                 */
                .max_skew_seconds(86400 * 365 * 10)
                .with_key(&key.pubkey)?;
            println!("old token {token:?} -> {vt}");

            for vk in inputs.iter() {
                match ut
                    .verify_for()
                    .magic_prefix(*b"abcdefgh")
                    .action("a", "b")
                    .action("c", "d")
                    /*
                     * Temporarily accept tokens up to ten years old:
                     */
                    .max_skew_seconds(86400 * 365 * 10)
                    .with_key(&vk.pubkey)
                {
                    Ok(vt) => {
                        assert_eq!(vk.id, vt.identity_filename().unwrap());
                        assert_eq!(vt.fingerprint(), vk.fingerprint());
                        println!("verify with {}: {vt}", vk.id);
                    }
                    Err(e) => {
                        assert_ne!(vk.id, vt.identity_filename().unwrap());
                        assert_ne!(vt.fingerprint(), vk.fingerprint());
                        println!("verify with {}: {e}", vk.id);
                    }
                }
            }
        }

        Ok(())
    }
}
