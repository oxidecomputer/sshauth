/*
 * Copyright 2024 Oxide Computer Company
 */

use anyhow::{bail, Result};
use ecdsa::signature::Signer;
use ssh_key::{Algorithm, EcdsaCurve, PrivateKey, PublicKey};

use crate::token::{
    Token, TokenAction, TokenFingerprint, TokenIdentity, TokenSigningBlobV1,
    TokenV1,
};
use crate::{agent, now_secs};

#[allow(clippy::large_enum_variant)]
enum TokenSignerMechanism {
    SshAgent {
        /**
         * The path to the SSH agent to use for signing purposes.
         */
        authsock: String,
        /**
         * The SSH key we should tell the agent to use to sign our tokens.
         */
        key: PublicKey,
    },
    Key {
        /**
         * The private key to use for signing purposes.
         */
        privkey: PrivateKey,
    },
}

/**
 * A token signer should be created for each combination of key source (e.g.,
 * SSH agent authentication socket path) and identity.  Individual tokens may
 * then be generated using TokenSigner::sign_for().
 */
pub struct TokenSigner {
    mech: TokenSignerMechanism,

    /**
     * The identity to use when creating tokens.
     */
    identity: Option<TokenIdentity>,

    /**
     * Should we include the SSH key fingerprint in the token?
     */
    include_fingerprint: bool,

    /**
     * A prefix that the consuming system can override to introduce some
     * purposeful incompatibility between tokens generated by this library but
     * for different applications.  Aims to reduce the likeihood of a
     * cross-protocol attack, where an attacker can convince a client to hash
     * certain data unintentionally.
     */
    magic_prefix: [u8; 8],
}

impl TokenSigner {
    /**
     * Begin configuring a token signer with a key stored in an SSH agent.
     */
    pub fn using_authsock<S: AsRef<str>>(
        sock: S,
    ) -> Result<TokenSignerBuilder> {
        Ok(TokenSignerBuilder {
            authsock: Some(sock.as_ref().to_string()),
            key: None,
            privkey: None,
            identity: None,
            include_fingerprint: false,
            magic_prefix: crate::MAGIC_PREFIX_DEFAULT,
        })
    }

    pub fn using_private_key(
        privkey: PrivateKey,
    ) -> Result<TokenSignerBuilder> {
        match privkey.algorithm() {
            Algorithm::Ecdsa { curve: EcdsaCurve::NistP256 }
            | Algorithm::Ed25519 => (),
            _ => {
                bail!("unsupported SSH key algorithm: {}", privkey.algorithm())
            }
        }
        Ok(TokenSignerBuilder {
            authsock: None,
            key: None,
            privkey: Some(privkey.clone()),
            identity: None,
            include_fingerprint: false,
            magic_prefix: crate::MAGIC_PREFIX_DEFAULT,
        })
    }

    /**
     * Begin creating a token for a particular action using the configured key
     * source and identity data.
     */
    pub fn sign_for(&self) -> TokenBuilder {
        let fingerprint = if self.include_fingerprint {
            Some(TokenFingerprint::Sha256(
                match &self.mech {
                    TokenSignerMechanism::SshAgent { key, .. } => key,
                    TokenSignerMechanism::Key { privkey } => {
                        privkey.public_key()
                    }
                }
                .fingerprint(ssh_key::HashAlg::Sha256)
                .sha256()
                .unwrap(),
            ))
        } else {
            None
        };

        TokenBuilder {
            signer: self,
            blob: TokenSigningBlobV1 {
                transmitted: TokenV1 {
                    identity: self.identity.clone(),
                    fingerprint,
                    timestamp: now_secs(),
                },
                action: Default::default(),
            },
        }
    }
}

pub struct TokenSignerBuilder {
    authsock: Option<String>,
    key: Option<PublicKey>,
    privkey: Option<PrivateKey>,
    identity: Option<TokenIdentity>,
    include_fingerprint: bool,
    magic_prefix: [u8; 8],
}

impl TokenSignerBuilder {
    pub fn magic_prefix(&mut self, pfx: [u8; 8]) -> &mut Self {
        self.magic_prefix = pfx;
        self
    }

    pub fn key(&mut self, key: PublicKey) -> &mut Self {
        self.key = Some(key);
        self
    }

    pub fn identity_filename<S: AsRef<str>>(&mut self, name: S) -> &mut Self {
        self.identity =
            Some(TokenIdentity::FileName(name.as_ref().to_string()));
        self
    }

    pub fn include_fingerprint(&mut self, include: bool) -> &mut Self {
        self.include_fingerprint = include;
        self
    }

    pub fn build(&mut self) -> Result<TokenSigner> {
        let identity = match &self.identity {
            Some(t @ TokenIdentity::FileName(name)) => {
                if !crate::valid_identity(name.as_str()) {
                    bail!("invalid identity name {name:?}");
                }

                Some(t.clone())
            }
            None => {
                if !self.include_fingerprint {
                    bail!("token must include an identity or a fingerprint");
                }

                None
            }
        };

        let mech = if let Some(authsock) = &self.authsock {
            if self.privkey.is_some() {
                bail!("cannot provide both a private key and an SSH agent");
            }

            if let Some(key) = &self.key {
                TokenSignerMechanism::SshAgent {
                    authsock: authsock.clone(),
                    key: key.clone(),
                }
            } else {
                bail!(
                    "must call .key() to provide a public key for \
                    SSH agent signing"
                );
            }
        } else if let Some(privkey) = &self.privkey {
            if self.authsock.is_some() || self.key.is_some() {
                bail!("cannot provide both a private key and an SSH agent");
            }

            TokenSignerMechanism::Key { privkey: privkey.clone() }
        } else {
            /*
             * This shouldn't occur!
             */
            bail!("no key mechanism selected (either SSH agent or static key)");
        };

        Ok(TokenSigner {
            mech,
            identity,
            include_fingerprint: self.include_fingerprint,
            magic_prefix: self.magic_prefix,
        })
    }
}

#[derive(Clone)]
pub struct TokenBuilder<'a> {
    signer: &'a TokenSigner,
    blob: TokenSigningBlobV1,
}

impl TokenBuilder<'_> {
    pub fn action_clear(&mut self) {
        self.blob.action.clear();
    }

    pub fn action<K, V>(&mut self, key: K, value: V) -> &mut Self
    where
        K: AsRef<str>,
        V: AsRef<str>,
    {
        self.blob.action.push(TokenAction {
            key: key.as_ref().to_string(),
            value: value.as_ref().to_string(),
        });
        self
    }

    pub fn actions<I, K, V>(&mut self, actions: I) -> &mut Self
    where
        I: IntoIterator<Item = (K, V)>,
        K: AsRef<str>,
        V: AsRef<str>,
    {
        for (key, value) in actions.into_iter() {
            self.action(key, value);
        }
        self
    }

    pub fn action_opt<K, V>(&mut self, action: Option<(K, V)>) -> &mut Self
    where
        K: AsRef<str>,
        V: AsRef<str>,
    {
        if let Some((key, value)) = action {
            self.action(key, value);
        }
        self
    }

    pub async fn sign(&mut self) -> Result<Token> {
        /*
         * Make sure the timestamp is fresh, in case this builder sat around for
         * sometime prior to use.
         */
        self.blob.transmitted.timestamp = now_secs();

        let blob = self.blob.pack(self.signer.magic_prefix);

        let sig = match &self.signer.mech {
            TokenSignerMechanism::SshAgent { authsock, key } => {
                agent::sign(authsock, key, &blob).await?
            }
            TokenSignerMechanism::Key { privkey } => {
                match privkey.algorithm() {
                    Algorithm::Ecdsa { curve: EcdsaCurve::NistP256 }
                    | Algorithm::Ed25519 => {
                        privkey.key_data().try_sign(&blob)?
                    }
                    _ => {
                        /*
                         * This should not happen, because the builder restricts
                         * the key algorithms we are willing to accept.
                         */
                        bail!("unsupported key algorithm");
                    }
                }
            }
        };

        Ok(self.blob.into_token(sig.try_into()?))
    }
}
